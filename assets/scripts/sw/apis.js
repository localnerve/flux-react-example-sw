/***
 * Copyright (c) 2015 Alex Grant (@localnerve), LocalNerve LLC
 * Copyrights licensed under the BSD License. See the accompanying LICENSE file for terms.
 *
 * Handling for api gets.
 *
 * The module 'data' is generated by the build.
 * @see grunt/tasks/service-worker.js
 */
/* global Request, URL */
'use strict';

var toolbox = require('sw-toolbox');
var data = require('./data');

/**
 * strip search time!
 * Removes the search/query portion from a URL.
 * E.g. stripSearchParameters("http://example.com/index.html?a=b&c=d")
 *     âž” "http://example.com/index.html"
 */
function stripSearchParameters(url) {
  var strippedUrl = new URL(url);
  strippedUrl.search = '';
  return strippedUrl.toString();
}

/**
 * Handle an api request.
 *
 * Api requests are read-thru cached.
 *
 * All api requests are CSRF protected, so we include the cookie and ignoreSearch
 * on the cache match.
 *
 * ignoreSearch option is not implemented yet in cache.match,
 * so we stripSearchParameters to ignoreSearch ourselves in the request.
 * https://code.google.com/p/chromium/issues/detail?id=426309
 */
function handleApiRequest (request, values, options) {
  var req = new Request(stripSearchParameters(request.url), {
    credentials: 'include'
  });
  return toolbox.networkFirst(req, values, options);
}

/**
 * Install route handlers for all api paths.
 * Since this only catches api gets and caches them, it doesn't catch
 * api gets not made.
 *
 * NOTE:
 *   For every app render, on any entry route, there is always one api get that
 *   is never made, because it is not required - it was already complete in the
 *   initial server-side-render and its data is available in app state.
 * TODO:
 *   Think of a nice way to cache responses to this api request not made with
 *   the data that is already here.
 *   1. we know what api request will not be made - it's always the one for
 *      the currentRoute on 'init'.
 *   2. we could setup to catch this api request separately using matching rules.
 *   3. we could find that data in app state and return it for the response.
 * Example:
 *   The api get for the home route is not made for the app rendered on '/'.
 *   If the user starts the app on /contact and goes to '/' (offline), that
 *   req-res mapping will not be in the cache.
 */
function installApiGetRequestProxies () {
  data.api_gets.forEach(function (path) {
    toolbox.router.get(path+'*', handleApiRequest, {
      debug: data.debug
    });
  });
}

module.exports = {
  // for now, just handle get requests
  setupApiRequests: installApiGetRequestProxies
};
