/***
 * Copyright (c) 2015 Alex Grant (@localnerve), LocalNerve LLC
 * Copyrights licensed under the BSD License. See the accompanying LICENSE file for terms.
 *
 * Handling for api requests.
 *
 * The module 'data' is generated by the build.
 * @see grunt/tasks/service-worker.js
 */
/* global Request, Response, Promise */
'use strict';

var toolbox = require('sw-toolbox');
var data = require('./data');
var debug = require('./utils/debug')('apis');
var networkFirst = require('./utils/customNetworkFirst');
var init = require('./init');
// var idb = require('./utils/idb');

/**
 * Defer post requests until later by storing them in IndexedDB.
 * This is called if the fetch fails.
 *
 * TODO:
 * As of 10/1/2015, Chrome seems to not support Request in structured data clone algo.
 * Looking to see how to best replay the full Request.
 *
 * @param {Object} request - A Request object to use to make the post request.
 * @return A Response Promise that reflects the success or failure of this operation.
 */
function deferPostRequest (request) {
  /*
  return idb.put(idb.stores.posts, Date.now().toString(), request).then(function () {
    return new Promise(function (resolve) {
      // possibly the response body needs to reflect the request body,
      // it does in real life. :-)
      resolve(new Response('ok', {
        status: 203
      }));
    });
  });
  */

  // Just a placeholder for now to reflect failure.
  return new Promise(function (resolve) {
    resolve(new Response('', {
      status: 500
    }));
  });
}

/**
 * Create the network request for fetch.
 *
 * Api is CSRF protected, so we include the cookie.
 *
 * @param {Object} request - The Request object from sw-toolbox.
 * @returns A Request object that includes the cookie.
 */
function networkRequest (request) {
  return new Request(request.clone(), { credentials: 'same-origin' });
}

/**
 * Create a request for cache.
 *
 * This exists because:
 * ignoreSearch option is not implemented yet in cache.match/matchAll,
 * so we stripSearchParameters to ignoreSearch ourselves in the request we cache.
 * https://code.google.com/p/chromium/issues/detail?id=426309
 *
 * Response from Google:
 * https://github.com/GoogleChrome/sw-toolbox/issues/35
 *
 * @param {Object} request - A Request object from sw-toolbox.
 * @returns A string of the modified request url to be used in caching.
 */
function cacheRequest (request) {
  return networkFirst.stripSearchParameters(request.url);
}

/**
 * Install route handlers for all api paths.
 *
 * NOTE:
 *   Network First, Fallback to Cache, Fallback to Content
 *   For every app render, on any entry route, there is always one api GET that
 *   is never made, because it is not required - it was already made on the
 *   server for the initial render - but its data is available in app state
 *   (in the ContentStore). This is why init.resourceContentResponse is used
 *   for cacheMissFallback.
 *
 * Example:
 *   The api get for the home route is not made for the app rendered on '/'.
 *   While offline, if the user starts the app on /contact and goes to '/', that
 *   req-res mapping will not be in the cache.
 */
function installApiRequestProxies () {
  data.api_paths.forEach(function (path) {
    debug(toolbox.options, 'install api handler', path);

    // Handle get requests
    toolbox.router.get(path+'*', networkFirst.routeHandlerFactory(
      networkRequest, cacheRequest, init.resourceContentResponse
    ), {
      debug: toolbox.options.debug
    });

    // Handle post requests
    toolbox.router.post(path+'*', networkFirst.routeHandlerFactory(
      networkRequest, networkRequest, deferPostRequest
    ), {
      debug: toolbox.options.debug
    });
  });
}

module.exports = {
  setupApiRequests: installApiRequestProxies
};
