/***
 * Copyright (c) 2015 Alex Grant (@localnerve), LocalNerve LLC
 * Copyrights licensed under the BSD License. See the accompanying LICENSE file for terms.
 *
 * Handling for api requests.
 *
 * The module 'data' is generated by the build.
 * @see grunt/tasks/service-worker.js
 */
/* global Request, URL, fetch, caches */
'use strict';

var toolbox = require('sw-toolbox');
var data = require('./data');
var debug = require('./debug')('apis');
var content = require('./content');

/**
 * strip search!
 * Removes the search/query portion from a URL.
 * E.g. stripSearchParameters("http://example.com/index.html?a=b&c=d")
 *     âž” "http://example.com/index.html"
 */
function stripSearchParameters(url) {
  var strippedUrl = new URL(url);
  strippedUrl.search = '';
  return strippedUrl.toString();
}

/**
 * Handle an api request.
 *
 * Api requests are read-thru cached (network first strategy). Net failures
 * fallback to cache, and cache failures fallback to initially rendered content
 * in IndexedDB init.content.
 *
 * Api is CSRF protected, so we include the cookie and ignoreSearch
 * on the cache match.
 * Api requests that fail to be found in cache
 *
 * ignoreSearch option is not implemented yet in cache.match/matchAll,
 * so we stripSearchParameters to ignoreSearch ourselves in the request we cache.
 * https://code.google.com/p/chromium/issues/detail?id=426309
 *
 * Response from Google:
 * https://github.com/GoogleChrome/sw-toolbox/issues/35
 *
 * NOTE:
 *   Network First, Fallback to Cache, Fallback to Content
 *   For every app render, on any entry route, there is always one api GET that
 *   is never made, because it is not required - it was already made on the
 *   server for the initial render - but its data is available in app state
 *   (in the ContentStore). This is why content.resourceContentResponse.
 *   This populated in the 'init' command by content.storeOnlineContent.
 *
 * Example:
 *   The api get for the home route is not made for the app rendered on '/'.
 *   While offline, if the user starts the app on /contact and goes to '/', that
 *   req-res mapping will not be in the cache.
 */
function handleApiRequest (request, values, options) {
  options = options || {};
  // A request that sends CSRF token, cookies
  var reqNet = new Request(request.url, { credentials: 'include' });
  // A request that omits CSRF token, cookies.
  var reqCache = stripSearchParameters(request.url);

  return fetch(reqNet).then(function (response) {
    if (response.ok) {
      return caches.open(toolbox.options.cacheName).then(function (cache) {
        debug(options, 'caching successful network request', reqNet);
        return cache.put(reqCache, response.clone()).then(function () {
          return response;
        });
      });
    }
    // Raise an error and trigger the catch
    throw response;
  }).catch(function (error) {
    debug(options, 'network req failed, fallback to cache', error);

    // Returned cached response, if there's none, try getting from content.
    return caches.open(toolbox.options.cacheName).then(function (cache) {
      var response = cache.match(reqCache);
      return response.then(function (data) {
        if (!data) {
          return content.resourceContentResponse(reqCache);
        }
        return response;
      });
    });
  });
}

/**
 * Install route handlers for all api paths.
 */
function installApiRequestProxies () {
  data.api_paths.forEach(function (path) {
    debug(toolbox.options, 'install api handler', path);

    // for now, just handle get requests
    toolbox.router.get(path+'*', handleApiRequest, {
      debug: toolbox.options.debug
    });

    // TODO: handle the post request.
    // This could store in indexedDB and use background sync to resolve.
  });
}

module.exports = {
  setupApiRequests: installApiRequestProxies
};
