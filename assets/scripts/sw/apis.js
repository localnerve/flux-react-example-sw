/***
 * Copyright (c) 2015 Alex Grant (@localnerve), LocalNerve LLC
 * Copyrights licensed under the BSD License. See the accompanying LICENSE file for terms.
 *
 * Handling for api requests.
 *
 * The module 'data' is generated by the build.
 * @see grunt/tasks/service-worker.js
 */
/* global Request, URL, fetch, caches */
'use strict';

var toolbox = require('sw-toolbox');
var data = require('./data');
var debug = require('./debug')('apis');

/**
 * strip search time!
 * Removes the search/query portion from a URL.
 * E.g. stripSearchParameters("http://example.com/index.html?a=b&c=d")
 *     âž” "http://example.com/index.html"
 */
function stripSearchParameters(url) {
  var strippedUrl = new URL(url);
  strippedUrl.search = '';
  return strippedUrl.toString();
}

/**
 * Handle an api request.
 *
 * Api requests are read-thru cached (network first strategy).
 * Api is CSRF protected, so we include the cookie and ignoreSearch
 * on the cache match.
 *
 * ignoreSearch option is not implemented yet in cache.match/matchAll,
 * so we stripSearchParameters to ignoreSearch ourselves in the request we cache.
 * https://code.google.com/p/chromium/issues/detail?id=426309
 *
 * Response from Google:
 * https://github.com/GoogleChrome/sw-toolbox/issues/35
 */
function handleApiRequest (request, values, options) {
  options = options || {};
  // A request that sends CSRF token, cookies
  var reqNet = new Request(request.url, { credentials: 'include' });
  // A request that omits CSRF token, cookies.
  var reqCache = stripSearchParameters(request.url);

  return fetch(reqNet).then(function (response) {
    if (response.ok) {
      return caches.open(toolbox.options.cacheName).then(function (cache) {
        debug(options, 'caching successful network request', reqNet);
        return cache.put(reqCache, response.clone()).then(function () {
          return response;
        });
      });
    }
    // Raise an error and trigger the catch
    throw response;
  }).catch(function (error) {
    debug(options, 'network req failed, fallback to cache', error);
    return caches.open(toolbox.options.cacheName).then(function (cache) {
      return cache.match(reqCache);
    });
  });
}

/**
 * Install route handlers for all api paths.
 *
 * Since this only catches api requests and caches them, it doesn't catch
 * api requests not made.
 *
 * NOTE:
 *   For every app render, on any entry route, there is always one api get that
 *   is never made, because it is not required - it was already made on the
 *   server for the initial render - but its data is available in app state.
 * TODO:
 *   Think of a nice way to cache responses to this api request not made with
 *   the data that is already here.
 *   1. we know what api request will not be made - it's always the one for
 *      the currentRoute on 'init'.
 *   2. we could setup to catch this api request separately using matching rules.
 *   3. we could find that data in app state and return it for the response.
 * Example:
 *   The api get for the home route is not made for the app rendered on '/'.
 *   While offline, if the user starts the app on /contact and goes to '/', that
 *   req-res mapping will not be in the cache.
 */
function installApiRequestProxies () {
  data.api_paths.forEach(function (path) {
    debug(toolbox.options, 'install api handler', path);

    // for now, just handle get requests
    toolbox.router.get(path+'*', handleApiRequest, {
      debug: toolbox.options.debug
    });
    // TODO: handle the post request.
    // This could store in indexedDB and use background sync to resolve.
  });
}

module.exports = {
  setupApiRequests: installApiRequestProxies
};
